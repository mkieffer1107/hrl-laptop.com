<context>
<directory_tree>
phased_array/
├── .DS_Store
├── .vscode/
│   └── settings.json
├── LICENSE.txt
├── README.md
├── package-lock.json
├── package.json
├── phased_array_prompt.txt
├── src/
│   ├── .DS_Store
│   ├── assets/
│   │   ├── .DS_Store
│   │   ├── blue.png
│   │   ├── logo.png
│   │   ├── matlab.png
│   │   └── red.png
│   ├── index.html
│   ├── simulation.js
│   └── style.css
└── webpack.config.js
</directory_tree>

<files>

<file>
<path>.vscode/settings.json</path>
<content>
{
    "liveServer.settings.port": 5502
}
</content>
</file>

<file>
<path>LICENSE.txt</path>
<content>
The MIT License (MIT)

Copyright (c) 2024 DesignersNest (https://codepen.io/designersnest/pen/gOaXPbr)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

</content>
</file>

<file>
<path>README.md</path>
<content>
# Laptop Open on Hover CSS3 Animation

A Pen created on CodePen.io. Original URL: [https://codepen.io/designersnest/pen/gOaXPbr](https://codepen.io/designersnest/pen/gOaXPbr).


</content>
</file>

<file>
<path>package.json</path>
<content>
{
  "name": "phased_array",
  "version": "1.0.0",
  "description": "A Pen created on CodePen.io. Original URL: [https://codepen.io/designersnest/pen/gOaXPbr](https://codepen.io/designersnest/pen/gOaXPbr).",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack --mode production",
    "start": "webpack serve --open --mode development"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "css-loader": "^7.1.2",
    "file-loader": "^6.2.0",
    "html-webpack-plugin": "^5.6.0",
    "mini-css-extract-plugin": "^2.9.1",
    "style-loader": "^4.0.0",
    "webpack": "^5.94.0",
    "webpack-cli": "^5.1.4"
  }
}

</content>
</file>

<file>
<path>src/index.html</path>
<content>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Laptop Animation with Simulation</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Background canvas for Matrix rain effect -->
  <canvas id="matrixRainCanvas" style="display: none; position: fixed; top: 0; left: 0; z-index: -1;"></canvas>

  <div class="container">
    <div class="mockup mockup-macbook loaded">
      <div class="part top">
        <img src="https://d1xm195wioio0k.cloudfront.net/images/mockup/macbook-top.svg" alt="" class="top">
        <img src="https://d1xm195wioio0k.cloudfront.net/images/mockup/macbook-cover.svg" alt="" class="cover">

        <!-- Canvas starts hidden and will be shown when the laptop opens -->
        <canvas id="waveCanvas" style="display: none;"></canvas>
      </div>
      <div class="part bottom">
        <img src="https://d1xm195wioio0k.cloudfront.net/images/mockup/macbook-cover.svg" alt="" class="cover">
        <img src="https://d1xm195wioio0k.cloudfront.net/images/mockup/macbook-bottom.svg" alt="" class="bottom">
      </div>

      <!-- Logo Images (Initially hidden) -->
      <img id="logoImage" src="assets/logo.png" alt="Logo" style="display: none;">
      <img id="matlabImage" src="assets/matlab.png" alt="Matlab Logo" style="display: none;">
    </div>
  </div>

  <!-- Red and Blue Pills (Initially visible) -->
  <img id="redPill" src="assets/red.png" alt="Red Pill" style="position: absolute; bottom: 20%; left: 20%; width: 95px; cursor: pointer;">
  <img id="bluePill" src="assets/blue.png" alt="Blue Pill" style="position: absolute; bottom: 20%; right: 20%; width: 100px; cursor: pointer;">

  <!-- Controls (Initially hidden) -->
  <div id="controls" style="display: none; text-align: center; color: #ffffff; font-size: 18px; font-family: Arial, sans-serif; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);">
    <label for="angleInput">Steering Angle (θ): <span id="angleValue">0°</span></label>
    <input type="range" id="angleInput" min="-90" max="90" value="0" style="width: 20%; display: block; margin: 10px auto;">

    <label for="wavelengthInput">Wavelength: <span id="wavelengthValue">100</span></label>
    <input type="range" id="wavelengthInput" min="50" max="200" value="100" style="width: 20%; display: block; margin: 10px auto;">

    <label for="frequencyInput">Frequency: <span id="frequencyValue">0.02</span></label>
    <input type="range" id="frequencyInput" min="0.01" max="0.05" step="0.005" value="0.02" style="width: 20%; display: block; margin: 10px auto;">

    <label for="amplitudeInput">Amplitude: <span id="amplitudeValue">1</span></label>
    <input type="range" id="amplitudeInput" min="0.5" max="2" step="0.1" value="1" style="width: 20%; display: block; margin: 10px auto;">

    <label for="numSourcesInput">Number of Sources: <span id="numSourcesValue">5</span></label>
    <input type="range" id="numSourcesInput" min="1" max="10" value="5" style="width: 20%; display: block; margin: 10px auto;">

    <label for="spacingInput">Spacing: <span id="spacingValue">50</span></label>
    <input type="range" id="spacingInput" min="20" max="100" value="50" style="width: 20%; display: block; margin: 10px auto;">

    <button id="toggleLowerHalf" style="background-color: #444; color: #fff; border: 1px solid #fff; padding: 10px 20px; margin-top: 20px;">Disable Lower Half</button>
  </div>

  <!-- Simulation Script -->
  <script src="simulation.js" defer></script>

  <!-- Event Listener and Matrix Rain Script -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const mockup = document.querySelector('.mockup');
      const canvas = document.getElementById('waveCanvas');
      const logoImage = document.getElementById('logoImage');
      const matlabImage = document.getElementById('matlabImage');
      const matrixCanvas = document.getElementById('matrixRainCanvas');
      const topPart = document.querySelector('.mockup .part.top');
      const controls = document.getElementById('controls');
      
      // Red and blue pills
      const redPill = document.getElementById('redPill');
      const bluePill = document.getElementById('bluePill');

      // Flag to indicate if we should initialize the canvas after transition
      let shouldInitializeCanvas = false;

      // Variables for the matrix rain effect
      let matrixRainInterval;

      // Function to initialize Matrix rain effect
      function startMatrixRain() {
        matrixCanvas.style.display = 'block';
        const ctx = matrixCanvas.getContext('2d');
        matrixCanvas.width = window.innerWidth;
        matrixCanvas.height = window.innerHeight;

        const letters = Array(256).join(1).split('');
        const fontSize = 14;
        
        function drawMatrixRain() {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
          ctx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
          ctx.fillStyle = '#0F0'; // Green color
          ctx.font = `${fontSize}px monospace`;

          letters.forEach((yPos, index) => {
            const text = String.fromCharCode(0x30A0 + Math.random() * 96);
            const xPos = index * fontSize;
            ctx.fillText(text, xPos, yPos);
            letters[index] = yPos > matrixCanvas.height + Math.random() * 1e4 ? 0 : yPos + fontSize;
          });
        }

        matrixRainInterval = setInterval(drawMatrixRain, 50);
      }

      // Function to stop Matrix rain effect
      function stopMatrixRain() {
        clearInterval(matrixRainInterval);
        matrixCanvas.style.display = 'none';
      }

      // Toggle opening/closing laptop and showing/hiding controls, images, and rain effect
      mockup.addEventListener('click', function () {
        mockup.classList.toggle('opened');
        
        if (mockup.classList.contains('opened')) {
          // Show controls and start matrix rain after the laptop opens
          controls.style.display = 'block';
          shouldInitializeCanvas = true;
          redPill.style.display = 'none';
          bluePill.style.display = 'none';
          startMatrixRain(); // Start the Matrix rain effect
        } else {
          // Hide canvas, logos, controls, and stop matrix rain when the laptop is closed
          canvas.style.display = 'none';
          logoImage.style.display = 'none';
          matlabImage.style.display = 'none';
          controls.style.display = 'none';
          redPill.style.display = 'block';
          bluePill.style.display = 'block';
          stopMatrixRain(); // Stop the Matrix rain effect
          animationRunning = false; // Stop simulation animation
          shouldInitializeCanvas = false; // Do not initialize
        }
      });

      // Listen for transitionend event on the top part
      topPart.addEventListener('transitionend', function (event) {
        if (shouldInitializeCanvas && mockup.classList.contains('opened')) {
          // Show canvas and logos after the laptop has fully opened
          canvas.style.display = 'block';
          logoImage.style.display = 'block';
          matlabImage.style.display = 'block';

          setCanvasSize();  // Initialize the canvas size when animation completes
          animationRunning = true; // Start animation
          animate(); // Start the animation loop
          shouldInitializeCanvas = false; // Reset flag
        }
      });

      // Red pill click event: Open the laptop
      redPill.addEventListener('click', function () {
        mockup.classList.add('opened');
        redPill.style.display = 'none';
        bluePill.style.display = 'none';
        controls.style.display = 'block';
        shouldInitializeCanvas = true;
        startMatrixRain(); // Start the Matrix rain effect
      });

      // Blue pill click event: Redirect to external URL
      bluePill.addEventListener('click', function () {
        window.location.href = 'https://www.apple.com/apple-music/';
      });

      // Handle window resize for matrix canvas size
      window.addEventListener('resize', () => {
        matrixCanvas.width = window.innerWidth;
        matrixCanvas.height = window.innerHeight;
      });
    });
  </script>
</body>
</html>
</content>
</file>

<file>
<path>src/simulation.js</path>
<content>
// https://www.analog.com/media/en/analog-dialogue/volume-54/number-2/phased-array-antenna-patterns-part-1-linear-array-beam-characteristics-and-array-factor.pdf

document.addEventListener("DOMContentLoaded", function() {
    // set up the canvas
    const canvas = document.getElementById('waveCanvas');
    const ctx = canvas.getContext('2d');
  
    // Expose variables and functions globally
    window.animationRunning = false;
  
    window.setCanvasSize = function() {
      const mockupTop = document.querySelector('.mockup .part.top');
      const rect = mockupTop.getBoundingClientRect();
  
      canvas.width = rect.width * 0.92;  // 92% width like the original video
      canvas.height = rect.height * 0.80;  // 80% height
  
      // Reinitialize sources with new canvas size
      initSources();
    };
  
    // default simulation values
    let wavelength = 100;   // pixels
    let frequency = 0.02;   // cycles / frame
    let amplitude = 1;      // pixels
    let numSources = 5;     
    let spacing = 50;       // pixels
    let blockLowerHalf = false;
    let time = 0;           // frame count
    let sources = [];       // store the source nodes
    
    
    function initSources() {
      sources = [];
      const startX = (canvas.width - (numSources - 1) * spacing) / 2;
      const yPosition = canvas.height - canvas.height * 0.1;
      for (let i = 0; i < numSources; i++) {
        const x = startX + i * spacing;
        sources.push(new Source(x, yPosition));
      }
    }
  
    class Source {
      constructor(x, y, phase = 0) {
        this.x = x;
        this.y = y;
        this.phase = phase; // phase offset for beam steering
      }
      getColor() {
        const phaseShift = Math.sin(this.phase - time * 0.05); // Calculate phase shift based on time
        const intensity = (phaseShift + 1) / 2; // Normalize between 0 and 1
        const r = Math.floor(intensity * 255); // Map intensity to red color channel
        const b = 255 - r; // Complementary blue color for contrast
        return `rgb(${r}, 0, ${b})`;
      }
    }
  
    // Do not initialize sources here; they will be initialized after canvas size is set
    // initSources();
  
    function waveFunction(x, y, source) {
      // zero out anything below the sources if bottom blocked
      if (blockLowerHalf && y > canvas.height - canvas.height * 0.1) {
        return 0;
      }
  
      // calculate the distance from source to (x, y)
      const dx = x - source.x;
      const dy = y - source.y;
      const r = Math.sqrt(dx * dx + dy * dy) + 0.0001;
      const k = (2 * Math.PI) / wavelength;  // angular wave number
      const omega = 2 * Math.PI * frequency; // angular frequency
      return amplitude * Math.sin(k * r - omega * time + source.phase);
    }
  
    function steerBeam(thetaDegrees) {
      // beam steering with phase shift calculation for far field
      const theta = (thetaDegrees * Math.PI) / 180;
      const k = (2 * Math.PI) / wavelength;  // angular wave number
      const deltaPhi = (2 * Math.PI * spacing * Math.sin(theta)) / wavelength;
  
      for (let n = 0; n < sources.length; n++) {
        sources[n].phase = n * deltaPhi;
      }
    }
  
    // HSV to RGB conversion (for visualizing wave intensities)
    function HSVtoRGB(h, s, v) {
      let r, g, b;
      let i = Math.floor(h * 6);
      let f = h * 6 - i;
      let p = v * (1 - s);
      let q = v * (1 - f * s);
      let t = v * (1 - (1 - f) * s);
  
      switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
      }
      return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
    }
  
    // Expose animate function globally
    window.animate = function() {
      if (!window.animationRunning) return;
  
      if (canvas.style.display !== 'none') {
        time += 1;
        draw();
      }
      requestAnimationFrame(animate);
    };
  
    // Do not start the animation loop immediately
    // animate(); // Remove or comment out this line
  
    // Draw function
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      const data = imageData.data;
      const step = 4;
  
      for (let y = 0; y < canvas.height; y += step) {
        for (let x = 0; x < canvas.width; x += step) {
          let totalAmplitude = 0;
  
          for (const source of sources) {
            totalAmplitude += waveFunction(x, y, source);
          }
  
          const normalizedAmplitude = (totalAmplitude + amplitude * sources.length) / (2 * amplitude * sources.length);
          const gamma = 0.7;
          const adjustedAmplitude = Math.pow(normalizedAmplitude, gamma);
          const hue = (1 - adjustedAmplitude) * 240;
          const rgb = HSVtoRGB(hue / 360, 1, 1);
  
          for (let i = 0; i < step; i++) {
            for (let j = 0; j < step; j++) {
              if (x + i < canvas.width && y + j < canvas.height) {
                const index = ((x + i) + (y + j) * canvas.width) * 4;
                data[index] = rgb.r;
                data[index + 1] = rgb.g;
                data[index + 2] = rgb.b;
                data[index + 3] = 255;
              }
            }
          }
        }
      }
  
      ctx.putImageData(imageData, 0, 0);
      drawAxes();
  
      // Draw sources as circles
      for (const source of sources) {
        drawSource(source);
      }
  
      // Draw the current beam direction arrow (black arrow based on angle)
      const centerX = canvas.width / 2;
      const centerY = canvas.height - canvas.height * 0.1;
  
      const beamAngle = parseFloat(angleInput.value);
      const beamArrowColor = 'black';
  
      const angleRadians = (beamAngle * Math.PI) / 180;
      const beamLength = 50;
  
      const beamToX = centerX + beamLength * Math.sin(angleRadians);
      const beamToY = centerY - beamLength * Math.cos(angleRadians); // Calculate the end of the arrow
  
      drawArrow(ctx, centerX, centerY, beamToX, beamToY, beamArrowColor);
  
      // Add label for current beam direction
      ctx.fillStyle = 'black';
      ctx.font = '16px Arial';
      ctx.fillText(`θ = ${beamAngle}°`, beamToX + 5, beamToY + 15);
  
      // Draw a line to indicate the blocked region (if applicable)
      if (blockLowerHalf) {
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - canvas.height * 0.1);
        ctx.lineTo(canvas.width, canvas.height - canvas.height * 0.1);
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  
    // Draw source as a circle with color based on its phase
    function drawSource(source) {
      ctx.beginPath();
      ctx.arc(source.x, source.y, 10, 0, Math.PI * 2); // Draw circle at source position
      ctx.fillStyle = source.getColor(); // Get color based on phase
      ctx.fill();
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.stroke(); // Outline the source
    }
  
    // Arrow drawing function
    function drawArrow(ctx, fromX, fromY, toX, toY, color) {
      const headLength = 10; // Length of the arrowhead
      const dx = toX - fromX;
      const dy = toY - fromY;
      const angle = Math.atan2(dy, dx);
  
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
  
      // Draw line
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.stroke();
  
      // Draw arrowhead
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(
        toX - headLength * Math.cos(angle - Math.PI / 6),
        toY - headLength * Math.sin(angle - Math.PI / 6)
      );
      ctx.lineTo(
        toX - headLength * Math.cos(angle + Math.PI / 6),
        toY - headLength * Math.sin(angle + Math.PI / 6)
      );
      ctx.lineTo(toX, toY);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }
  
    // Helper function to draw axes
    function drawAxes() {
      ctx.strokeStyle = 'gray';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - canvas.height * 0.1);
      ctx.lineTo(canvas.width, canvas.height - canvas.height * 0.1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
    }
  
    // Ensure controls are properly initialized
    function initializeControls() {
      // Angle input and beam steering
      window.angleInput = document.getElementById('angleInput');
      const angleValueDisplay = document.getElementById('angleValue');
      angleInput.addEventListener('input', (e) => {
        const angle = parseFloat(e.target.value);
        angleValueDisplay.textContent = `${angle}°`;
        steerBeam(angle);
      });
  
      // Initialize other controls if they exist
      // Wavelength control
      window.wavelengthInput = document.getElementById('wavelengthInput');
      const wavelengthValueDisplay = document.getElementById('wavelengthValue');
      wavelengthInput.addEventListener('input', (e) => {
        wavelength = parseFloat(e.target.value);
        wavelengthValueDisplay.textContent = wavelength;
      });
  
      // Frequency control
      window.frequencyInput = document.getElementById('frequencyInput');
      const frequencyValueDisplay = document.getElementById('frequencyValue');
      frequencyInput.addEventListener('input', (e) => {
        frequency = parseFloat(e.target.value);
        frequencyValueDisplay.textContent = frequency;
      });
  
      // Amplitude control
      window.amplitudeInput = document.getElementById('amplitudeInput');
      const amplitudeValueDisplay = document.getElementById('amplitudeValue');
      amplitudeInput.addEventListener('input', (e) => {
        amplitude = parseFloat(e.target.value);
        amplitudeValueDisplay.textContent = amplitude;
      });
  
      // Number of sources control
      window.numSourcesInput = document.getElementById('numSourcesInput');
      const numSourcesValueDisplay = document.getElementById('numSourcesValue');
      numSourcesInput.addEventListener('input', (e) => {
        numSources = parseInt(e.target.value);
        numSourcesValueDisplay.textContent = numSources;
        initSources(); // Reinitialize sources when the number changes
      });
  
      // Spacing control
      window.spacingInput = document.getElementById('spacingInput');
      const spacingValueDisplay = document.getElementById('spacingValue');
      spacingInput.addEventListener('input', (e) => {
        spacing = parseInt(e.target.value);
        spacingValueDisplay.textContent = spacing;
        initSources(); // Reinitialize sources when spacing changes
      });
  
      // Block lower half toggle
      const toggleButton = document.getElementById('toggleLowerHalf');
      toggleButton.addEventListener('click', () => {
        blockLowerHalf = !blockLowerHalf;
        toggleButton.textContent = blockLowerHalf ? 'Enable Lower Half' : 'Disable Lower Half';
      });
  
      // Update initial values
      angleValueDisplay.textContent = `${angleInput.value}°`;
      wavelengthValueDisplay.textContent = wavelengthInput.value;
      frequencyValueDisplay.textContent = frequencyInput.value;
      amplitudeValueDisplay.textContent = amplitudeInput.value;
      numSourcesValueDisplay.textContent = numSourcesInput.value;
      spacingValueDisplay.textContent = spacingInput.value;
    }
  
    // Initialize controls when the canvas becomes visible
    initializeControls();
  
    // Listen for window resize to adjust canvas size
    window.addEventListener('resize', () => {
      if (canvas.style.display === 'block') {
        setCanvasSize();
      }
    });
  });
</content>
</file>

<file>
<path>src/style.css</path>
<content>
body {
  margin: 20px;
}

.container {
  text-align: center;
}

.mockup {
  position: relative; /* Ensure positioning context for absolute elements */
  display: inline-block;
  position: relative;
  z-index: 3;
  text-align: center;
  font-size: 0;
  perspective: 2400px;
  perspective-origin: 50% 100%;
  opacity: 0;
  transition: 500ms opacity;
  cursor: pointer;
}

.mockup.loaded {
  opacity: 1;
}

.mockup .part .top,
.mockup .part .bottom {
  position: absolute;
  top: 0;
  left: 0;
}

.mockup .part.top {
  transform: translate3d(0, 0, 0) rotateX(-90deg);
}

.mockup.opened .part.top {
  transform: translate3d(0, 0, 0) rotateX(0deg);
}

.mockup .part {
  display: inline-block;
  position: relative;
  transform-style: preserve-3d;
  transform-origin: 50% 100%;
  transition: 900ms;
}

.mockup.opened .part .top {
  transform: translate3d(0, 0, -11px) rotateX(90deg) scale(1, 1);
}

.mockup .part .top {
  transform-origin: 50% 0;
  transform: translate3d(0, 0, -11px) rotateX(90deg);
  transition: 900ms;
}

.mockup img {
  display: block;
  max-width: 100%;
  backface-visibility: hidden;
}

.mockup .part .cover {
  position: relative;
}

/* Styling the canvas to fit inside the mockup like the video */
.mockup canvas {
  display: block;
  position: absolute;
  top: 8%;
  left: 4%;
  width: 92%;
  height: 80%; /* Ensuring it fills the height proportionally */
  border-radius: 6px;
  backface-visibility: hidden;
  transform: translate3d(0, 0, 1px);
}

.mockup .part.bottom {
  position: absolute;
  top: 0;
  left: 0;
  transform: translate3d(0, 0, 0) rotateX(-90deg);
}

.mockup .part .bottom {
  transform-origin: 50% 0;
  transform: translate3d(0, 0, 0) rotateX(90deg);
}

/* Controls styling */
#controls {
  margin-top: 20px;
  text-align: center;
}

#controls label {
  display: block;
  margin-bottom: 5px;
}

#controls input[type="range"] {
  width: 300px;
  margin-bottom: 15px;
}

#controls button {
  padding: 10px 20px;
  font-size: 16px;
}

/* Position the logo image */
#logoImage {
  position: absolute;
  display: none; /* Initially hidden */
  left: 50%;
  transform: translateX(-50%);
  /* Place the logo between the canvas and the bottom part */
  /* Adjust 'top' value as needed to position the logo */
  top: 90%; /* Adjust 100px to position logo correctly */
  width: 80px; /* Adjust size as needed */
}

#matlabImage {
  position: absolute;
  display: none; /* Initially hidden */
  top: 10%; /* Adjust as needed to position the logos correctly */
  width: 80px; /* Adjust size as needed */
  left: 83%
}

/* Ensure the canvas is properly positioned */
#waveCanvas {
  position: absolute;
  top: 8%;
  left: 4%;
  width: 92%;
  height: 80%;
  border-radius: 6px;
  display: none; /* Initially hidden */
}
</content>
</file>

<file>
<path>webpack.config.js</path>
<content>
const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");

module.exports = {
  entry: "./src/index.html",  // Entry point of your application
  output: {
    path: path.resolve(__dirname, "dist"),  // Output directory
    filename: "bundle.js",  // Name of the bundled JavaScript file
  },
  module: {
    rules: [
      {
        test: /\.html$/,
        use: [
          {
            loader: "html-loader",
            options: { minimize: true },
          },
        ],
      },
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, "css-loader"],
      },
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: [
          {
            loader: "file-loader",
            options: {
              name: "[name].[hash].[ext]",
              outputPath: "assets/",
            },
          },
        ],
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/index.html",
      filename: "./index.html",
    }),
    new MiniCssExtractPlugin({
      filename: "[name].[contenthash].css",
    }),
  ],
};
</content>
</file>

</files>
</context>